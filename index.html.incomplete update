<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>15m Volume + Structure Probability Scanner</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<style>
:root{
  --bg:#0f1720;
  --panel:#0b1220;
  --border:#172033;
  --muted:#9fb3cc;
  --bull:#22c55e;
  --bear:#fb7185;
  --neutral:#facc15;
  --accent:#38bdf8;
}

body{
  font-family:Inter,system-ui,Arial;
  background:var(--bg);
  color:#e6eef8;
  margin:16px;
}

h1{font-size:18px;margin-bottom:6px}
h2{font-size:16px;margin:16px 0 8px}

.muted{color:var(--muted);font-size:13px}

button,input,select{
  padding:8px 12px;
  border-radius:6px;
  border:1px solid #334155;
  background:var(--panel);
  color:#e6eef8;
}

button.primary{
  background:var(--bull);
  border:0;
  color:#042e16;
  font-weight:700;
  cursor:pointer;
}
button.primary:disabled{
  opacity:.5;
  cursor:not-allowed;
}

button.secondary{
  background:#334155;
  border:0;
}

.row{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-bottom:10px;
}

.grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(280px,1fr));
  gap:12px;
}

.card{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:12px;
  padding:12px;
  position:relative;
  transition:transform .15s ease, box-shadow .15s ease;
}
.card:hover{
  transform:translateY(-2px);
  box-shadow:0 8px 24px rgba(0,0,0,.6);
}

.bull{color:var(--bull)}
.bear{color:var(--bear)}
.neutral{color:var(--neutral)}
.prob{font-weight:700;margin-top:4px}

.star{
  position:absolute;
  top:8px;
  right:8px;
  cursor:pointer;
  font-size:16px;
}

.close{
  position:absolute;
  top:8px;
  right:32px; /* ‚¨Ö moved left */
  cursor:pointer;
  color:var(--bear);
  font-size:16px;
}

.progress{
  height:10px;
  background:var(--border);
  border-radius:6px;
  overflow:hidden;
  margin:8px 0 14px;
}
.progress > div{
  height:100%;
  width:0%;
  background:linear-gradient(90deg,var(--bull),#4ade80);
  transition:width .2s linear;
}

.filter-box{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:8px;
  padding:8px;
}

  .status-running{ color: var(--accent); }
.status-done{ color: var(--bull); }
.status-error{ color: var(--bear); }

  .reset-flash{
  animation: resetPulse .6s ease;
}

@keyframes resetPulse{
  0%{
    box-shadow:0 0 0 rgba(34,197,94,0);
    background:#334155;
  }
  50%{
    box-shadow:0 0 14px rgba(34,197,94,.8);
    background:#1f2937;
  }
  100%{
    box-shadow:0 0 0 rgba(34,197,94,0);
    background:#334155;
  }
}

  .analyze-running{
  background:linear-gradient(90deg,#334155,#1f2937,#334155);
  background-size:200% 100%;
  animation: analyzeFlow 1.2s linear infinite;
  box-shadow:0 0 12px rgba(56,189,248,.6);
}

@keyframes analyzeFlow{
  0%{background-position:0% 0}
  100%{background-position:200% 0}
}

  #dailyRSIStatus{
  padding:6px 8px;
  border-radius:6px;
  background:#0b1220;
  border:1px solid #172033;
  }
</style>
</head>

<body>
<h1>üìä 15m Volume ‚Üí Structure Probability Scanner</h1>
<div class="muted">Dominant volume + structure confirmation only</div>
<div class="muted">
  Last update: <span id="timestamp">‚Äî</span><br>
</div>

<!-- ACTION ROW -->
  <div class="row filter-box">

  <!-- NORMAL SCAN -->
  <div>
    <button class="primary" onclick="startNormalScan()">‚ñ∂ Normal Scan</button>
    <button class="secondary" onclick="stopNormalScan()">‚ñ† Stop</button>
  </div>

  <!-- DAILY RSI SCAN -->
  <div>
    <button class="primary" onclick="startDailyRSIScan()">‚ñ∂ Daily RSI Scan</button>
    <button class="secondary" onclick="stopDailyRSIScan()">‚ñ† Stop</button>
  </div>

  <!-- VOLUME BREAK SCAN -->
  <div>
    <button class="primary" onclick="startVolumeBreakScan()">‚ñ∂ Volume Break Scan</button>
    <button class="secondary" onclick="stopVolumeBreakScan()">‚ñ† Stop</button>
  </div>

      <input id="symbolSearch" placeholder="BTCUSDT"/>
  <button class="secondary" id="analyzeBtn" onclick="runSearch()">Analyze</button>
  </div>


<div id="manualStatus" class="muted"></div>


<!-- FILTERS ROW -->
<div class="row filter-box">
   <button class="secondary" id="resetFiltersBtn" onclick="resetFilters()">
    Reset Filters
   </button>
  
  <select id="filterBias">
    <option value="all">All Bias</option>
    <option>Bullish Continuation</option>
    <option>Bullish Defense</option>
    <option>Bearish Continuation</option>
    <option>Bearish Defense</option>
  </select>

  <select id="filterVol">
    <option value="all">All Volume</option>
    <option value="bull">Bull Volume</option>
    <option value="bear">Bear Volume</option>
  </select>

  <select id="filterVolBreak">
  <option value="all">All Volume Breaks</option>
  <option value="yes">24h Volume Breakout</option>
  <option value="no">No Volume Breakout</option>
  </select>

  <select id="filterProb">
    <option value="0">Any Prob</option>
    <option value="60">‚â• 60%</option>
    <option value="70">‚â• 70%</option>
    <option value="80">‚â• 80%</option>
  </select>

  <select id="filterStructure">
  <option value="all">All Structures</option>
  <option value="support holding">Support Holding</option>
  <option value="support broken">Support Broken</option>
  <option value="resistance failed">Resistance Failed</option>
  <option value="resistance broken">Resistance Broken</option>
  <option value="none">None</option>
  </select>

  <select id="filterDailyRSI">
    <option value="all">All Daily RSI</option>
    <option value="MAX ZONE PUMP">MAX ZONE PUMP</option>
    <option value="MAX ZONE DUMP">MAX ZONE DUMP</option>
    <option value="BALANCE ZONE PUMP">BALANCE ZONE PUMP</option>
    <option value="BALANCE ZONE DUMP">BALANCE ZONE DUMP</option>
    <option value="LOWEST ZONE PUMP">LOWEST ZONE PUMP</option>
    <option value="LOWEST ZONE DUMP">LOWEST ZONE DUMP</option>
  </select>
</div>

<!-- SORT + RESET ROW -->
<div class="row">
  <select id="sortField">
    <option value="prob">Probability</option>
    <option value="change">24h Change</option>
    <option value="price">Price</option>
  </select>

  <select id="sortOrder">
    <option value="desc">Descending</option>
    <option value="asc">Ascending</option>
  </select>
</div>

<div class="progress">
  <div id="progressFill"></div>
</div>

  <div class="muted" id="dailyRSIStatus">
  üìÖ Daily RSI Scan: ‚Äî
  </div>

<h2>‚≠ê Favorites</h2>
<div class="grid" id="favGrid"></div>

<h2>üîç Manual</h2>
<div class="grid" id="searchGrid"></div>

<h2>üü¢ Top Gainers</h2>
<div class="grid" id="greenGrid"></div>

<h2>üî¥ Top Losers</h2>
<div class="grid" id="redGrid"></div>

<script>
/* ================= CONFIG ================= */
const API="https://fapi.binance.com";
const DELAY=300;
const AUTO_INTERVAL=60*1000;

const BLACKSET=new Set([
"ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT",
"LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT",
"OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT",
"NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","MEMEFIUSDT",
"NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT","STRAXUSDT",
"COMBOUSDT","AI16ZUSDT","MILKUSDT","TOKENUSDT","SXPUSDT",
"MYROUSDT","1000XUSDT","DARUSDT","PORT3USDT","SKATEUSDT",
"AIAUSDT","AMBUSDT","FLMUSDT","PERPUSDT","OBOLUSDT","SWELLUSDT","FTMUSDT"
]);

const favSet=new Set();
let countdownTimer=null;
let autoEnabled=true;
  let activeSearchSymbol = null;
  let dailyRSIMatchCount = 0;
let dailyRSIScanned = 0;

  const SCAN_STATE = {
  normal: {
    running: false,
    timer: null,
    interval: 60 * 1000
  },
  dailyRSI: {
    running: false,
    timer: null,
    interval: 10 * 60 * 1000 // heavier scan
  },
  volumeBreak: {
    running: false,
    timer: null,
    interval: 2 * 60 * 1000 // event-based
  }
};
  
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const fetchJSON=async u=>(await fetch(u)).json();

  /* ================= SOUND ALERT ================= */
const volumeAlert = new Audio(
  "https://actions.google.com/sounds/v1/alarms/beep_short.ogg"
);

  /* ================= VOLUME BREAK MEMORY ================= */
const VOLUME_BREAK_MEMORY = {
  // symbol: { lastCandleTime, domV }
};

let volumeAlertCooldown = {};
const ALERT_COOLDOWN = 60 * 1000; // 1 minute per symbol

  function setScanStatus(text){
  const el = document.getElementById("dailyRSIStatus");
  if(el) el.textContent = text;
}

function setProgress(current, total){
  const fill = document.getElementById("progressFill");
  if(!fill || !total) return;
  fill.style.width = Math.round((current / total) * 100) + "%";
}

function resetProgress(){
  const fill = document.getElementById("progressFill");
  if(fill) fill.style.width = "0%";
}



  function stopAllScans(){
  stopNormalScan();
  stopDailyRSIScan();
  stopVolumeBreakScan();
  }


/* === IMPROVED 15m SWING DETECTION (CONFIRMED) === */
function findSwings(h, l, c, v){
  const supports = [];
  const resistances = [];

  // parameters (tunable but safe defaults)
  const LOOKBACK = 2;          // candles on each side
  const CONFIRM = 2;           // candles to confirm reaction
  const VOL_MULT = 1.2;        // volume must be above average

  const avgVol = v.slice(-40).reduce((a,b)=>a+b,0) / 40;

  for(let i = LOOKBACK; i < h.length - CONFIRM; i++){

    /* === SWING LOW (SUPPORT) === */
    let isSwingLow = true;
    for(let j = 1; j <= LOOKBACK; j++){
      if(l[i] >= l[i-j] || l[i] >= l[i+j]){
        isSwingLow = false;
        break;
      }
    }

    if(isSwingLow){
      // confirmation: price must move away upward
      let confirmed = true;
      for(let k = 1; k <= CONFIRM; k++){
        if(c[i+k] <= c[i]){
          confirmed = false;
          break;
        }
      }

      // volume filter (defense)
      if(confirmed && v[i] >= avgVol * VOL_MULT){
        supports.push(l[i]);
      }
    }

    /* === SWING HIGH (RESISTANCE) === */
    let isSwingHigh = true;
    for(let j = 1; j <= LOOKBACK; j++){
      if(h[i] <= h[i-j] || h[i] <= h[i+j]){
        isSwingHigh = false;
        break;
      }
    }

    if(isSwingHigh){
      // confirmation: price must move away downward
      let confirmed = true;
      for(let k = 1; k <= CONFIRM; k++){
        if(c[i+k] >= c[i]){
          confirmed = false;
          break;
        }
      }

      // volume filter (supply)
      if(confirmed && v[i] >= avgVol * VOL_MULT){
        resistances.push(h[i]);
      }
    }
  }

  return {
    supports: supports.slice(-2).reverse(),       // S1, S2
    resistances: resistances.slice(-2).reverse()  // R1, R2
  };
}

    /* ================= DAILY RSI CONTEXT ================= */
const DAILY_RSI_CACHE = {};
const DAILY_RSI_TTL = 6 * 60 * 60 * 1000; // 6 hours
const DAILY_RSI_INTERVAL = "1d";
const DAILY_RSI_LIMIT = 200;

  /* ================= RSI ================= */
function calculateRSI(closes, period=14){
  if(closes.length <= period) return [];
  let gains=0,losses=0,rsi=[];
  for(let i=1;i<=period;i++){
    const d=closes[i]-closes[i-1];
    d>0?gains+=d:losses-=d;
  }
  let avgG=gains/period, avgL=losses/period;
  rsi[period]=100-100/(1+(avgL===0?100:avgG/avgL));
  for(let i=period+1;i<closes.length;i++){
    const d=closes[i]-closes[i-1];
    avgG=(avgG*(period-1)+(d>0?d:0))/period;
    avgL=(avgL*(period-1)+(d<0?-d:0))/period;
    rsi[i]=100-100/(1+(avgL===0?100:avgG/avgL));
  }
  return rsi;
}

/* ================= RSI DIFF ================= */
function getRecentRSIDiff(rsi, lookback=14){
  const s=rsi.slice(-lookback);
  const hi=Math.max(...s);
  const lo=Math.min(...s);
  return {
    diff: +(hi - lo).toFixed(2),
    direction:
      s.at(-1)>s[0]?'pump':
      s.at(-1)<s[0]?'dump':'neutral'
  };
}

async function getDailyRSIContext(sym){
  const cached = DAILY_RSI_CACHE[sym];
  if(cached && Date.now() - cached.ts < DAILY_RSI_TTL){
    return cached.data;
  }

  try{
    const k = await fetchJSON(
      `${API}/fapi/v1/klines?symbol=${sym}&interval=${DAILY_RSI_INTERVAL}&limit=${DAILY_RSI_LIMIT}`
    );

    const closes = k.map(x=>+x[4]);
    const rsi = calculateRSI(closes);
    if(!rsi.length) return null;

    const d = getRecentRSIDiff(rsi);

    let label = "Neutral";
    if(d.direction==="pump" && d.diff>=25) label="MAX ZONE PUMP";
    else if(d.direction==="dump" && d.diff>=25) label="MAX ZONE DUMP";
    else if(d.direction==="pump" && d.diff>=18) label="BALANCE ZONE PUMP";
    else if(d.direction==="dump" && d.diff>=18) label="BALANCE ZONE DUMP";
    else if(d.direction==="pump" && d.diff<=8) label="LOWEST ZONE PUMP";
    else if(d.direction==="dump" && d.diff<=8) label="LOWEST ZONE DUMP";

    const data = { label, diff: d.diff, dir: d.direction };
    DAILY_RSI_CACHE[sym] = { data, ts: Date.now() };

    return data;
  }catch(e){
    return null;
  }
}

  function isDailyRSIActive(){
  return filterDailyRSI.value !== "all";
  }

  async function batchMap(items, batchSize, asyncFn){
  const results = [];
  for(let i = 0; i < items.length; i += batchSize){
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(x => asyncFn(x).catch(() => null))
    );
    results.push(...batchResults);
  }
  return results;
  }

/* ================= ANALYZE ================= */
async function analyze(sym,change){
  const k=await fetchJSON(`${API}/fapi/v1/klines?symbol=${sym}&interval=15m&limit=240`);
  await sleep(DELAY);

  const c=k.map(x=>+x[4]),h=k.map(x=>+x[2]),l=k.map(x=>+x[3]),v=k.map(x=>+x[5]);
  const price=c.at(-1);

  let domV = 0;
let domVBull = true;
let domVIndex = -1;


for(let i = k.length - 96; i < k.length - 1; i++){
  if(v[i] > domV){
    domV = v[i];
    domVBull = k[i][4] > k[i][1];
    domVIndex = i;
  }
}

const lastVol = v.at(-1);
const lastBull = k.at(-1)[4] > k.at(-1)[1];

const volumeBreakout = lastVol > domV;
const volumeBreakoutType =
  volumeBreakout
    ? (lastBull ? "Bull Volume Breakout" : "Bear Volume Breakout")
    : "No Volume Breakout";

  const bull = domVBull;

  const swings = findSwings(h,l,c,v);
const sw = {
  S: swings.supports || [],
  R: swings.resistances || []
};
  const sb=sw.S.some(x=>price<x);
  const rb=sw.R.some(x=>price>x);

  let bias="Neutral",prob=50,structure="none";
  if(bull){
    if(rb){bias="Bullish Continuation";prob=85;structure="resistance broken";}
    else if(sw.S.length){bias="Bullish Defense";prob=70;structure="support holding";}
    else{bias="Bull Trap Risk";prob=40;}
  }else{
    if(sb){bias="Bearish Continuation";prob=85;structure="support broken";}
    else if(sw.R.length){bias="Bearish Defense";prob=70;structure="resistance failed";}
    else{bias="Bear Trap Risk";prob=40;}
  }

    const dailyRSI = await getDailyRSIContext(sym);

  return {sym,price,change,bull,prob,bias,structure,S:sw.S,R:sw.R,dailyRSI,volumeBreakout,
  volumeBreakoutType,
  domV,
  lastVol};
}

/* ================= FILTERS ================= */
function applyFilters(){
  const b = filterBias.value;
  const v = filterVol.value;
  const p = +filterProb.value;
  const r = filterDailyRSI.value;
  const s = filterStructure.value;
  const vb = filterVolBreak.value;

  document.querySelectorAll(".card").forEach(c=>{
    let ok = true;

    if(b !== "all" && c.dataset.bias !== b) ok = false;
    if(v !== "all" && c.dataset.vol !== v) ok = false;
    if(p > 0 && +c.dataset.prob < p) ok = false;
    if(r !== "all" && c.dataset.dailyrsi !== r) ok = false;
    if(s !== "all" && c.dataset.structure !== s) ok = false;
    if(vb !== "all" && c.dataset.volbreak !== vb) ok = false;

    c.style.display = ok ? "" : "none";
  });
}

       function resetFilters(){
  filterBias.value = "all";
  filterVol.value = "all";
  filterProb.value = "0";
  filterDailyRSI.value = "all";
         filterStructure.value = "all";
           filterVolBreak.value = "all";
           

  applyFilters();

  // üîî visual feedback
  const btn = document.getElementById("resetFiltersBtn");
  const oldText = btn.textContent;

  btn.textContent = "Reset ‚úì";
  btn.classList.add("reset-flash");

  setTimeout(()=>{
    btn.textContent = oldText;
    btn.classList.remove("reset-flash");
  }, 800);
}

  function applySort(){
  const field = document.getElementById("sortField").value;
  const order = document.getElementById("sortOrder").value;

  ["greenGrid","redGrid","favGrid","searchGrid"].forEach(id=>{
    const grid = document.getElementById(id);
    if(!grid) return;

    const cards = [...grid.children];

    cards.sort((a,b)=>{
      const av = +a.dataset[field];
      const bv = +b.dataset[field];
      return order === "asc" ? av - bv : bv - av;
    });

    cards.forEach(c=>grid.appendChild(c));
  });
    }
  
/* ================= RENDER ================= */
function renderCard(d, el, isFav=false){
  const scope = el.id || "global";
const id = `card-${scope}-${d.sym}`;
  let card = document.getElementById(id);

  // create only once
  if(!card){
    card = document.createElement("div");
    card.id = id;
    card.className = "card";
    el.appendChild(card);
  }

  
  card.dataset.bias = d.bias;
card.dataset.vol  = d.bull ? "bull" : "bear";
card.dataset.prob = d.prob;
card.dataset.change = d.change;
card.dataset.price = d.price;
card.dataset.structure = d.structure || "none";
card.dataset.dailyrsi = d.dailyRSI?.label || "all";
  card.dataset.volbreak = d.volumeBreakout ? "yes" : "no";

  // üîî SOUND ALERT ‚Äî only on 24h volume breakout
if (d.volumeBreakout) {
  const now = Date.now();

  // prevent repeat spam per symbol
  if (!volumeAlertCooldown[d.sym] || now - volumeAlertCooldown[d.sym] > ALERT_COOLDOWN) {
    volumeAlert.play().catch(()=>{});
    volumeAlertCooldown[d.sym] = now;
  }
}

  card.innerHTML = `
    ${isFav
      ? `<div class="close" onclick="removeFav('${d.sym}')">‚úñ</div>`
      : `<div class="star" onclick="addFav('${d.sym}')">‚≠ê</div>`
    }
    <b>${d.sym}</b>
    
    ${d.dailyRSI ? `
  <div class="muted ${
    d.dailyRSI.dir==="pump"?"bull":
    d.dailyRSI.dir==="dump"?"bear":"neutral"
  }">
    üìÖ Daily RSI: ${d.dailyRSI.label}
    (Œî ${d.dailyRSI.diff})
  </div>
` : ""}

    <div class="muted">Price: ${d.price.toFixed(4)}</div>
    <div class="muted ${d.change>=0?"bull":"bear"}">
      24h Change: ${d.change.toFixed(2)}%
    </div>
    <div class="muted ${d.bull?"bull":"bear"}">
      ${d.bull?"Bullish":"Bearish"} Volume Control
    </div>
    
    ${d.volumeBreakout ? `
  <div class="muted ${
    d.volumeBreakoutType.includes("Bull") ? "bull" : "bear"
  }">
    üî• ${d.volumeBreakoutType}
    <br>
    <span class="muted">
      15m: ${d.lastVol.toLocaleString()}
      &nbsp;‚Ä∫&nbsp;
      24h High: ${d.domV.toLocaleString()}
    </span>
  </div>
` : `
  <div class="muted neutral">
    üìä No 24h Volume Breakout
  </div>
`}

    <div class="muted">Structure: ${d.structure}</div>

    <div class="prob ${
      d.bias.includes("Bull")?"bull":
      d.bias.includes("Bear")?"bear":"neutral"
    }">
      ${d.bias} ‚Äî ${d.prob}%
    </div>
    ${d.S[0]?`<div class="muted bear">S1: ${d.S[0].toFixed(4)}</div>`:""}
    ${d.S[1]?`<div class="muted bear">S2: ${d.S[1].toFixed(4)}</div>`:""}
    ${d.R[0]?`<div class="muted bull">R1: ${d.R[0].toFixed(4)}</div>`:""}
    ${d.R[1]?`<div class="muted bull">R2: ${d.R[1].toFixed(4)}</div>`:""}
  `;

  applyFilters();
}

  async function startNormalScan(){
  stopAllScans();

  SCAN_STATE.normal.running = true;
  resetProgress();
  setScanStatus("‚ñ∂ Normal Scan: starting‚Ä¶");

  async function tick(){
    if(!SCAN_STATE.normal.running) return;
    await runNormalScanOnce();
  }

  await tick();
  SCAN_STATE.normal.timer = setInterval(tick, SCAN_STATE.normal.interval);
}

  function stopNormalScan(){
  SCAN_STATE.normal.running = false;
  clearInterval(SCAN_STATE.normal.timer);
  setScanStatus("‚ñ∂ Normal Scan: stopped");
}

  async function runNormalScanOnce(){
  greenGrid.innerHTML = "";
  redGrid.innerHTML = "";
  resetProgress();

  const t = await fetchJSON(`${API}/fapi/v1/ticker/24hr`);
  const usdt = t.filter(x=>x.symbol.endsWith("USDT") && !BLACKSET.has(x.symbol));

  const g = [...usdt].sort((a,b)=>b.priceChangePercent-a.priceChangePercent).slice(0,30);
  const r = [...usdt].sort((a,b)=>a.priceChangePercent-b.priceChangePercent).slice(0,30);
  const all = [...g, ...r];

  let scanned = 0;
  const total = all.length;

  for(const x of all){
    if(!SCAN_STATE.normal.running) break;

    const d = await analyze(x.symbol, +x.priceChangePercent);
    renderCard(d, x.priceChangePercent>=0 ? greenGrid : redGrid);

    scanned++;
    setProgress(scanned, total);
    setScanStatus(`‚ñ∂ Normal Scan: ${scanned}/${total}`);

    await sleep(120);
  }

  timestamp.innerText = new Date().toLocaleString();
  setScanStatus("‚ñ∂ Normal Scan: completed ‚úì");
}

  async function startDailyRSIScan(){
  stopAllScans(); // üî• REQUIRED

  SCAN_STATE.dailyRSI.running = true;

  async function tick(){
    if(!SCAN_STATE.dailyRSI.running) return;
    await runDailyRSIScan(filterDailyRSI.value);
  }

  await tick();
  SCAN_STATE.dailyRSI.timer =
    setInterval(tick, SCAN_STATE.dailyRSI.interval);
}

  function stopDailyRSIScan(){
  SCAN_STATE.dailyRSI.running = false;
  clearInterval(SCAN_STATE.dailyRSI.timer);
  }

  async function startVolumeBreakScan(){
  stopAllScans(); // üî• REQUIRED

  SCAN_STATE.volumeBreak.running = true;

  async function tick(){
    if(!SCAN_STATE.volumeBreak.running) return;
    await runVolumeBreakScan();
  }

  await tick();
  SCAN_STATE.volumeBreak.timer =
    setInterval(tick, SCAN_STATE.volumeBreak.interval);
}

  function stopVolumeBreakScan(){
  SCAN_STATE.volumeBreak.running = false;
  clearInterval(SCAN_STATE.volumeBreak.timer);
  }

  async function runDailyRSIScan(targetLabel){
    if(!SCAN_STATE.dailyRSI.running) return;
    
  greenGrid.innerHTML = "";
  redGrid.innerHTML = "";
  progressFill.style.width = "0%";

  dailyRSIMatchCount = 0;
  dailyRSIScanned = 0;

  const statusEl = document.getElementById("dailyRSIStatus");
  statusEl.textContent = `üìÖ Daily RSI Scan: ${targetLabel} ‚Äî starting‚Ä¶`;

  const tickers = await fetchJSON(`${API}/fapi/v1/ticker/24hr`);
  const usdt = tickers.filter(
    x => x.symbol.endsWith("USDT") && !BLACKSET.has(x.symbol)
  );

  const total = usdt.length;

  /* === PHASE 1: FAST DAILY RSI BATCH SCAN === */
  const BATCH_SIZE = 10; // üî• safe + fast

  const rsiResults = await batchMap(usdt, BATCH_SIZE, async (x)=>{
    const rsi = await getDailyRSIContext(x.symbol);
    dailyRSIScanned++;

    progressFill.style.width =
      Math.round((dailyRSIScanned / total) * 100) + "%";

    statusEl.textContent =
      `üìÖ Daily RSI Scan: ${targetLabel} | ` +
      `Scanned: ${dailyRSIScanned}/${total} | ` +
      `Matches: ${dailyRSIMatchCount}`;

    return rsi && rsi.label === targetLabel
      ? { symbol: x.symbol, change: +x.priceChangePercent }
      : null;
  });

  const matches = rsiResults.filter(Boolean);
  dailyRSIMatchCount = matches.length;

  /* === PHASE 2: SAFE 15m ANALYSIS (SEQUENTIAL) === */
  for(const m of matches){
    const d = await analyze(m.symbol, m.change);
    renderCard(
      d,
      m.change >= 0 ? greenGrid : redGrid
    );
    await sleep(120); // keep this slow & safe
  }

  timestamp.innerText = new Date().toLocaleString();
  statusEl.textContent =
    `üìÖ Daily RSI Scan COMPLETE ‚Äî ${targetLabel} | ` +
    `Total Matches: ${dailyRSIMatchCount}`;

  applySort();
  applyFilters();
}

  async function runVolumeBreakScan(){
  greenGrid.innerHTML = "";
  redGrid.innerHTML = "";
  progressFill.style.width = "0%";

  const statusEl = document.getElementById("dailyRSIStatus");
  statusEl.textContent = "üî• 24h Volume Break Scan ‚Äî starting‚Ä¶";

  const tickers = await fetchJSON(`${API}/fapi/v1/ticker/24hr`);
  const usdt = tickers.filter(
    x => x.symbol.endsWith("USDT") && !BLACKSET.has(x.symbol)
  );

  const total = usdt.length;
  let scanned = 0;
  let matches = [];

  const BATCH_SIZE = 10;   // ‚úÖ SAFE
  const BATCH_DELAY = 180; // ms between batches

  /* === PHASE 1: FAST PARALLEL VOLUME SCAN === */
  for(let i = 0; i < usdt.length; i += BATCH_SIZE){
    const batch = usdt.slice(i, i + BATCH_SIZE);

    const results = await Promise.all(
      batch.map(async (x)=>{
        try{
          const k = await fetchJSON(
            `${API}/fapi/v1/klines?symbol=${x.symbol}&interval=15m&limit=97`
          );

          const v = k.map(c=>+c[5]);

          let domV = 0;
          for(let j=0;j<v.length-1;j++){
            if(v[j] > domV) domV = v[j];
          }

          const last = k.at(-1);
const lastVol = +last[5];
const lastTime = +last[6]; // candle close time

const mem = VOLUME_BREAK_MEMORY[x.symbol];

// detect NEW break only
if (
  lastVol > domV &&
  (
    !mem ||                      // never seen before
    lastTime > mem.lastCandleTime // new candle
  )
) {
  matches.push({
    symbol: x.symbol,
    change: +x.priceChangePercent
  });

  // üîê store memory
  VOLUME_BREAK_MEMORY[x.symbol] = {
    lastCandleTime: lastTime,
    domV
  };
}
       return null;

        }catch(e){
          return null;
        }
      })
    );

    results.filter(Boolean).forEach(r => matches.push(r));

    scanned += batch.length;
    progressFill.style.width =
      Math.round((scanned / total) * 100) + "%";

    statusEl.textContent =
      `üî• 24h Volume Break Scan | ${scanned}/${total} | Matches: ${matches.length}`;

    await sleep(BATCH_DELAY); // ‚õî rate-limit safety
  }

  /* === PHASE 2: FULL ANALYSIS (SEQUENTIAL & SAFE) === */
  for(const m of matches){
    const d = await analyze(m.symbol, m.change);
    renderCard(
      d,
      m.change >= 0 ? greenGrid : redGrid
    );
    await sleep(120);
  }

  timestamp.innerText = new Date().toLocaleString();
  statusEl.textContent =
    `üî• 24h Volume Break Scan COMPLETE ‚Äî Matches: ${matches.length}`;

  applySort();
  applyFilters();
  }
  
/* ================= FAVORITES ================= */
async function addFav(sym){
  if(BLACKSET.has(sym)) return;
  favSet.add(sym);
  const t=await fetchJSON(`${API}/fapi/v1/ticker/24hr?symbol=${sym}`);
  const d=await analyze(sym,+t.priceChangePercent);
  renderCard(d,favGrid,true);
}
function removeFav(sym){
  favSet.delete(sym);
  favGrid.innerHTML="";
  favSet.forEach(addFav);
}


/* ================= SEARCH ================= */
async function runSearch(){
  const status = document.getElementById("manualStatus");
  const btn = document.getElementById("analyzeBtn");
  const s = symbolSearch.value.toUpperCase();

  if(!s){
    status.textContent = "Manual status: No symbol entered";
    status.className = "muted status-error";
    return;
  }

  const sym = s.endsWith("USDT") ? s : s + "USDT";
  if(BLACKSET.has(sym)){
    status.textContent = `Manual status: ${sym} is blacklisted`;
    status.className = "muted status-error";
    return;
  }

  try{
  // üîí lock + animate button
  btn.disabled = true;
  btn.textContent = "Analyzing‚Ä¶";
  btn.classList.add("analyze-running");

  status.textContent = `Manual status: Analyzing ${sym}‚Ä¶`;
  status.className = "muted status-running";

  activeSearchSymbol = sym;
  searchGrid.innerHTML = "";

  const t = await fetchJSON(`${API}/fapi/v1/ticker/24hr?symbol=${sym}`);
  const d = await analyze(sym, +t.priceChangePercent);

  renderCard(d, searchGrid);

  status.textContent = `Manual status: ${sym} analysis completed`;
  status.className = "muted status-done";

}catch(err){
  console.error(err);
  status.textContent = `Manual status: Analysis failed`;
  status.className = "muted status-error";

}finally{
  // üîì unlock + reset button
  btn.disabled = false;
  btn.textContent = "Analyze";
  btn.classList.remove("analyze-running");
  }
}

["sortField","sortOrder"].forEach(id=>{
  document.getElementById(id).addEventListener("change", ()=>{
    applySort();
    applyFilters(); // keep filters applied
  });
});

[
  "filterBias",
  "filterVol",
  "filterProb",
  "filterStructure",
  "filterVolBreak"
].forEach(id=>{
  document.getElementById(id).addEventListener("change", applyFilters);
});

  

      setInterval(() => {
  const cutoff = Date.now() - 24 * 60 * 60 * 1000;
  for (const s in VOLUME_BREAK_MEMORY) {
    if (VOLUME_BREAK_MEMORY[s].lastCandleTime < cutoff) {
      delete VOLUME_BREAK_MEMORY[s];
    }
  }
}, 10 * 60 * 1000);
</script>
</body>
</html>
