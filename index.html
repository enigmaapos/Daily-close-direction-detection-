<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>15m Volume + Structure Probability Scanner</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<style>
:root{
  --bg:#0f1720;
  --panel:#0b1220;
  --border:#172033;
  --muted:#9fb3cc;
  --bull:#22c55e;
  --bear:#fb7185;
  --neutral:#facc15;
  --accent:#38bdf8;
}

body{
  font-family:Inter,system-ui,Arial;
  background:var(--bg);
  color:#e6eef8;
  margin:16px;
}

h1{font-size:18px;margin-bottom:6px}
h2{font-size:16px;margin:16px 0 8px}

.muted{color:var(--muted);font-size:13px}

button,input,select{
  padding:8px 12px;
  border-radius:6px;
  border:1px solid #334155;
  background:var(--panel);
  color:#e6eef8;
}

button.primary{
  background:var(--bull);
  border:0;
  color:#042e16;
  font-weight:700;
  cursor:pointer;
}
button.primary:disabled{
  opacity:.5;
  cursor:not-allowed;
}

button.secondary{
  background:#334155;
  border:0;
}

.row{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-bottom:10px;
}

.grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(280px,1fr));
  gap:12px;
}

.card{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:12px;
  padding:12px;
  position:relative;
  transition:transform .15s ease, box-shadow .15s ease;
}
.card:hover{
  transform:translateY(-2px);
  box-shadow:0 8px 24px rgba(0,0,0,.6);
}

.bull{color:var(--bull)}
.bear{color:var(--bear)}
.neutral{color:var(--neutral)}
.prob{font-weight:700;margin-top:4px}

.star{
  position:absolute;
  top:8px;
  right:8px;
  cursor:pointer;
  font-size:16px;
}

.close{
  position:absolute;
  top:8px;
  right:32px; /* ‚¨Ö moved left */
  cursor:pointer;
  color:var(--bear);
  font-size:16px;
}

.progress{
  height:10px;
  background:var(--border);
  border-radius:6px;
  overflow:hidden;
  margin:8px 0 14px;
}
.progress > div{
  height:100%;
  width:0%;
  background:linear-gradient(90deg,var(--bull),#4ade80);
  transition:width .2s linear;
}

.filter-box{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:8px;
  padding:8px;
}

  .status-running{ color: var(--accent); }
.status-done{ color: var(--bull); }
.status-error{ color: var(--bear); }

  .reset-flash{
  animation: resetPulse .6s ease;
}

@keyframes resetPulse{
  0%{
    box-shadow:0 0 0 rgba(34,197,94,0);
    background:#334155;
  }
  50%{
    box-shadow:0 0 14px rgba(34,197,94,.8);
    background:#1f2937;
  }
  100%{
    box-shadow:0 0 0 rgba(34,197,94,0);
    background:#334155;
  }
}

  .analyze-running{
  background:linear-gradient(90deg,#334155,#1f2937,#334155);
  background-size:200% 100%;
  animation: analyzeFlow 1.2s linear infinite;
  box-shadow:0 0 12px rgba(56,189,248,.6);
}

@keyframes analyzeFlow{
  0%{background-position:0% 0}
  100%{background-position:200% 0}
}

  #dailyRSIStatus{
  padding:6px 8px;
  border-radius:6px;
  background:#0b1220;
  border:1px solid #172033;
  }

  #marketGreen, #marketRed, #marketNet{
  font-weight:700;
  margin-right:12px;
  }

  .verdict-strong { color: var(--accent); }   /* confident */
.verdict-watch  { color: var(--neutral); }  /* timing */
.verdict-avoid  { color: var(--muted); }    /* no edge */

  #scrollTopBtn{
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 1px solid var(--border);
  background: var(--panel);
  color: var(--accent);
  font-size: 18px;
  cursor: pointer;
  display: none;
  z-index: 999;
  box-shadow: 0 6px 18px rgba(0,0,0,.6);
  transition: opacity .2s ease, transform .2s ease;
}

#scrollTopBtn:hover{
  transform: translateY(-2px);
  box-shadow: 0 10px 26px rgba(0,0,0,.8);
}
</style>
</head>

<body>
<h1>üìä 15m Volume ‚Üí Structure Probability Scanner</h1>
<div class="muted">Dominant volume + structure confirmation only</div>
<div class="muted">
  Last update: <span id="timestamp">‚Äî</span><br>
  Next scan in: <span id="nextScan">‚Äî</span>
</div>

<!-- ACTION ROW -->
<div class="row">
  <button class="primary" id="scanBtn" onclick="runScan()">Run Scan</button>
<button class="secondary" id="scanVolBreakBtn">
  üî• Scan 24h Volume Break
</button>
  <div class="row filter-box">
  <label class="muted" style="display:flex;align-items:center;gap:8px;cursor:pointer;">
    <input
      type="checkbox"
      id="toggle24hVolume"
      checked
    />
    üî• Auto 24h Volume Break Scan
  </label>
  </div>
  <input id="symbolSearch" placeholder="BTCUSDT"/>
  <button class="secondary" id="analyzeBtn" onclick="runSearch()">Analyze</button>
</div>

<div id="manualStatus" class="muted"></div>


<!-- FILTERS ROW -->
<div class="row filter-box">
   <button class="secondary" id="resetFiltersBtn" onclick="resetFilters()">
    Reset Filters
   </button>
  
  <select id="filterBias">
  <option value="all">All Bias</option>

  <optgroup label="Bullish">
    <option>Bullish Continuation</option>
    <option>Bullish Defense</option>
    <option>Bull Trap Risk</option>
  </optgroup>

  <optgroup label="Bearish">
    <option>Bearish Continuation</option>
    <option>Bearish Defense</option>
    <option>Bear Trap Risk</option>
  </optgroup>

  <optgroup label="Neutral">
    <option>Neutral</option>
  </optgroup>
</select>

  <select id="filterVol">
    <option value="all">All Volume</option>
    <option value="bull">Bull Volume</option>
    <option value="bear">Bear Volume</option>
  </select>

  <select id="filterVolBreak">
  <option value="all">All Volume Breaks</option>
  <option value="yes">24h Volume Breakout</option>
  <option value="no">No Volume Breakout</option>
  </select>

  <select id="filterProb">
    <option value="0">Any Prob</option>
    <option value="60">‚â• 60%</option>
    <option value="70">‚â• 70%</option>
    <option value="80">‚â• 80%</option>
  </select>

  <select id="filterStructure">
  <option value="all">All Structure Directions</option>
  <option value="support holding">Support Holding</option>
  <option value="support broken">Support Broken</option>
  <option value="resistance failed">Resistance Failed</option>
  <option value="resistance broken">Resistance Broken</option>
</select>

<select id="filterStructureQuality">
  <option value="all">All Structure Quality</option>
  <option value="accepted">Accepted</option>
  <option value="confirmed">Confirmed</option>
  <option value="unaccepted">Unaccepted</option>
  <option value="weak">Weak</option>
</select>

  <select id="filterDailyRSI">
    <option value="all">All Daily RSI</option>
    <option value="MAX ZONE PUMP">MAX ZONE PUMP</option>
    <option value="MAX ZONE DUMP">MAX ZONE DUMP</option>
    <option value="BALANCE ZONE PUMP">BALANCE ZONE PUMP</option>
    <option value="BALANCE ZONE DUMP">BALANCE ZONE DUMP</option>
    <option value="LOWEST ZONE PUMP">LOWEST ZONE PUMP</option>
    <option value="LOWEST ZONE DUMP">LOWEST ZONE DUMP</option>
  </select>
</div>

<div class="row filter-box">
  <select id="filterAIVerdict">
    <option value="all">All AI Verdicts</option>

    <optgroup label="High Probability">
      <option>STRONG CONTINUATION</option>
      <option>CONTROLLED CONTINUATION</option>
    </optgroup>

    <optgroup label="Watch / Timing">
      <option>WAIT FOR PULLBACK</option>
      <option>COUNTER-TREND</option>
    </optgroup>

    <optgroup label="Risk / Avoid">
      <option>TRAP RISK</option>
      <option>STRUCTURE WEAK / NO EDGE</option>
      <option>AVOID / NO TRADE</option>
    </optgroup>
  </select>
</div>

  <div class="row filter-box">
  <select id="filterTradeSide">
  <option value="all">All Trade Sides</option>
  <option value="LONG">LONG</option>
  <option value="SHORT">SHORT</option>
  <option value="WAIT">WAIT</option>
  </select>
  </div>
  
<!-- SORT + RESET ROW -->
<div class="row">
  <select id="sortField">
    <option value="change">24h Change</option>
    <option value="prob">Probability</option>
    <option value="price">Price</option>
  </select>

  <select id="sortOrder">
    <option value="desc">Descending</option>
    <option value="asc">Ascending</option>
  </select>
</div>

<div class="progress">
  <div id="progressFill"></div>
</div>

  <div class="muted" id="dailyRSIStatus">
  üß≠ Scanner Status: Idle
  </div>

  <div class="row filter-box">
  <div class="muted">
    üìä Market 24h Dominance
  </div>
  <div id="marketGreen" class="bull">üü¢ Green: ‚Äî</div>
  <div id="marketRed" class="bear">üî¥ Red: ‚Äî</div>
  <div id="marketNet" class="neutral">‚öñ Net: ‚Äî</div>
  </div>

<h2>‚≠ê Favorites</h2>
<div class="grid" id="favGrid"></div>

<h2>üîç Manual</h2>
<div class="grid" id="searchGrid"></div>

<h2>üü¢ Top Gainers</h2>
<div class="grid" id="greenGrid"></div>

<h2>üî¥ Top Losers</h2>
<div class="grid" id="redGrid"></div>

  <button id="scrollTopBtn" title="Back to top">‚¨Ü</button>

<script>
/* ================= CONFIG ================= */
const API="https://fapi.binance.com";
const DELAY=300;
const AUTO_INTERVAL=60*1000;
const AUTO_VOLUME_BREAK_INTERVAL = 15 * 60 * 1000; // 15 minutes
let autoVolBreakTimer = null;

  
const BLACKSET=new Set([
"ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT",
"LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT",
"OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT",
"NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","MEMEFIUSDT",
"NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT","STRAXUSDT",
"COMBOUSDT","AI16ZUSDT","MILKUSDT","TOKENUSDT","SXPUSDT",
"MYROUSDT","1000XUSDT","DARUSDT","PORT3USDT","SKATEUSDT",
"AIAUSDT","AMBUSDT","FLMUSDT","PERPUSDT","OBOLUSDT","SWELLUSDT","FTMUSDT","XCNUSDT",
  "RADUSDT","IDEXUSDT","SNTUSDT","BADGERUSDT","GLMRUSDT","ORBSUSDT","BALUSDT","KLAYUSDT",
  "UNFIUSDT","REEFUSDT","STPTUSDT","OMGUSDT","VOXELUSDT","QUICKUSDT","FISUSDT","MKRUSDT",
  "REIUSDT","KDAUSDT"
]);

const favSet=new Set();
let nextScanAt=null;
let countdownTimer=null;
let scanLock=false;
let autoEnabled=true;
  let isAutoScan = false;
let autoTimer = null;
  let activeSearchSymbol = null;
  let dailyRSIMatchCount = 0;
let dailyRSIScanned = 0;
  let last24hVolumeBreakAt = 0;
  let pending24hVolumeScan = false;
  let statusLocked = false;
  let auto24hVolumeEnabled = true; // ‚úÖ default ON
  

const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const fetchJSON=async u=>(await fetch(u)).json();

  /* ================= SOUND ALERT ================= */
const volumeAlert = new Audio(
  "https://actions.google.com/sounds/v1/alarms/beep_short.ogg"
);

  /* ================= VOLUME BREAK MEMORY ================= */
const VOLUME_BREAK_MEMORY = {
  // symbol: { lastCandleTime, domV }
};

let volumeAlertCooldown = {};
const ALERT_COOLDOWN = 60 * 1000; // 1 minute per symbol

  

  window.addEventListener("load", async () => {
  nextScanAt = Date.now() + AUTO_INTERVAL;
  startCountdown();

  startAutoScan();              // normal scan (1 min)

  isAutoScan = true;
  await runScan();
});

  
/* ================= COUNTDOWN ================= */
function startCountdown(){
  clearInterval(countdownTimer);
  countdownTimer=setInterval(()=>{
    if(!nextScanAt) return;
    const d=nextScanAt-Date.now();
    if(d<=0){
      nextScan.innerText="Ready";
      return;
    }
    const m=Math.floor(d/60000);
    const s=Math.floor((d%60000)/1000);
    nextScan.innerText=`${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  },1000);
}

/* ================= AUTO REFRESH ================= */
function startAutoScan(){
  if(autoTimer) clearInterval(autoTimer);
  autoTimer = setInterval(async ()=>{
    if(scanLock) return;
    if(filterDailyRSI.value !== "all") return; // ‚õî stop auto scan
    isAutoScan = true;
    await runScan();
  }, AUTO_INTERVAL);
}

  function setScanStatus(text){
  if (statusLocked) return;
  dailyRSIStatus.textContent = text;
}
  

  async function getFundingRate(sym){
  try{
    const d = await fetchJSON(
      `${API}/fapi/v1/premiumIndex?symbol=${sym}`
    );
    return +d.lastFundingRate * 100; // convert to %
  }catch(e){
    return null;
  }
  }

  function getFundingInfo(rate){
  if(rate === null) return { label: "Funding: ‚Äî", cls: "neutral" };

  if(rate >= 0.03) return { label: `Funding: +${rate.toFixed(3)}% (Crowded Longs)`, cls: "bull" };
  if(rate <= -0.03) return { label: `${rate.toFixed(3)}% (Crowded Shorts)`, cls: "bear" };
  if(Math.abs(rate) >= 0.015) return { label: `${rate.toFixed(3)}% (Elevated)`, cls: "neutral" };

  return { label: `${rate.toFixed(3)}% (Balanced)`, cls: "neutral" };
  }

  
  
      /* ================= AI VERDICTS ================= */

const AI_VERDICTS = {
  STRONG_CONTINUATION: "STRONG CONTINUATION",
  CONTROLLED_CONTINUATION: "CONTROLLED CONTINUATION",
  WAIT_FOR_PULLBACK: "WAIT FOR PULLBACK",
  HIGH_RISK_LATE_MOVE: "HIGH RISK / LATE MOVE",
  STRUCTURE_WEAK: "STRUCTURE WEAK / NO EDGE",
  COUNTER_TREND: "COUNTER-TREND BREAKOUT",
  TRAP_RISK: "TRAP RISK",
  AVOID: "AVOID / NO TRADE"
};

const AI_VERDICT_TIERS = {
  "STRONG CONTINUATION": {
    tier: 1,
    label: "TIER 1 ‚Äî HIGH PROBABILITY",
    verdictClass: "verdict-strong"
  },
  "CONTROLLED CONTINUATION": {
    tier: 2,
    label: "TIER 2 ‚Äî HIGH PROBABILITY (CONTROLLED)",
    verdictClass: "verdict-strong"
  },
  "WAIT FOR PULLBACK": {
    tier: 3,
    label: "TIER 3 ‚Äî WAIT / TIMING",
    verdictClass: "verdict-watch"
  },
  "COUNTER-TREND BREAKOUT": {
    tier: 4,
    label: "TIER 4 ‚Äî COUNTER-TREND",
    verdictClass: "verdict-watch"
  },
  "HIGH RISK / LATE MOVE": {
    tier: 5,
    label: "TIER 5 ‚Äî HIGH RISK",
    verdictClass: "verdict-avoid"
  },
  "STRUCTURE WEAK / NO EDGE": {
    tier: 6,
    label: "TIER 6 ‚Äî NO EDGE",
    verdictClass: "verdict-avoid"
  },
  "TRAP RISK": {
    tier: 6,
    label: "TIER 6 ‚Äî TRAP RISK",
    verdictClass: "verdict-avoid"
  },
  "AVOID / NO TRADE": {
    tier: 6,
    label: "TIER 6 ‚Äî AVOID",
    verdictClass: "verdict-avoid"
  }
};

/* ================= AI VERDICT LOGIC ================= */

function getAIFinalVerdict(d) {
  const structure = d.structure || "none";
  const bias = d.bias || "";
  const trend = d.mainTrend || "neutral";
  const prob = d.prob || 0;

  const funding = d.fundingRate ?? 0;
  const extremeLongCrowd  = funding >= 0.03;
  const extremeShortCrowd = funding <= -0.03;
  const elevatedFunding   = Math.abs(funding) >= 0.015;

  const hasVolumeBreak = d.volumeBreakout === true;
  const fakeVol = d.fakeVolumeBreak === true;

  const rsiLabel = d.dailyRSI?.label || "Neutral";

  const bullishBreak =
    structure.includes("resistance broken") && trend === "bullish";

  const bearishBreak =
    structure.includes("support broken") && trend === "bearish";

  const anyBreak = structure.includes("broken");

  let verdict = AI_VERDICTS.AVOID;
  let reason = "Conditions are mixed and lack a statistical edge.";

  /* PRIORITY 1 ‚Äî TRAP */
  if (bias.includes("Trap") || fakeVol) {
    verdict = AI_VERDICTS.TRAP_RISK;
    reason = "Volume spike lacks acceptance and structure stability is weak.";
  }

  /* PRIORITY 2 ‚Äî STRONG CONTINUATION */
  else if (
    (bullishBreak || bearishBreak) &&
    hasVolumeBreak &&
    !rsiLabel.includes("MAX")
  ) {
    verdict = AI_VERDICTS.STRONG_CONTINUATION;
    reason = "Structure, trend, and sustained participation are aligned.";
  }

  /* PRIORITY 3 ‚Äî CONTROLLED CONTINUATION */
  else if (
    (bullishBreak || bearishBreak) &&
    !hasVolumeBreak &&
    !rsiLabel.includes("MAX")
  ) {
    verdict = AI_VERDICTS.CONTROLLED_CONTINUATION;
    reason = "Structure aligns with trend, but participation remains selective.";
  }

  /* PRIORITY 4 ‚Äî WAIT (OVEREXTENDED) */
  else if (anyBreak && rsiLabel.includes("MAX")) {
    verdict = AI_VERDICTS.WAIT_FOR_PULLBACK;
    reason = "Momentum is stretched after a structure break.";
  }

  /* PRIORITY 5 ‚Äî COUNTER-TREND */
  else if (
    anyBreak &&
    (
      (structure.includes("resistance broken") && trend === "bearish") ||
      (structure.includes("support broken") && trend === "bullish")
    )
  ) {
    verdict = AI_VERDICTS.COUNTER_TREND;
    reason = "Structure break occurred against the dominant trend.";
  }

  /* PRIORITY 6 ‚Äî STRUCTURE WEAK */
  else if (structure === "none" || prob < 60) {
    verdict = AI_VERDICTS.STRUCTURE_WEAK;
    reason = "No confirmed structure or probability edge present.";
  }

  /* ================= FUNDING MODIFIERS ================= */

  if (
    verdict === AI_VERDICTS.STRONG_CONTINUATION &&
    (
      (trend === "bullish" && extremeLongCrowd) ||
      (trend === "bearish" && extremeShortCrowd)
    )
  ) {
    verdict = AI_VERDICTS.CONTROLLED_CONTINUATION;
    reason += " Funding shows crowded positioning.";
  }

  if (
    verdict === AI_VERDICTS.CONTROLLED_CONTINUATION &&
    elevatedFunding &&
    !hasVolumeBreak
  ) {
    verdict = AI_VERDICTS.WAIT_FOR_PULLBACK;
    reason += " Elevated funding increases entry risk.";
  }

  if (
    verdict === AI_VERDICTS.TRAP_RISK &&
    elevatedFunding
  ) {
    reason += " Crowded funding confirms trap probability.";
  }

  /* ================= RSI15 MOMENTUM ================= */

  if (
    verdict === AI_VERDICTS.WAIT_FOR_PULLBACK &&
    d.rsi15Momentum === "reclaim" &&
    !rsiLabel.includes("MAX")
  ) {
    verdict = AI_VERDICTS.CONTROLLED_CONTINUATION;
    reason += " RSI15 reclaimed 50, improving momentum alignment.";
  }

  if (
    verdict === AI_VERDICTS.CONTROLLED_CONTINUATION &&
    d.rsi15Momentum === "accel" &&
    hasVolumeBreak
  ) {
    verdict = AI_VERDICTS.STRONG_CONTINUATION;
    reason += " RSI15 accelerating with volume confirmation.";
  }

  if (
    (verdict === AI_VERDICTS.STRONG_CONTINUATION ||
     verdict === AI_VERDICTS.CONTROLLED_CONTINUATION) &&
    d.rsi15Momentum === "decay"
  ) {
    verdict = AI_VERDICTS.WAIT_FOR_PULLBACK;
    reason += " RSI15 momentum is decaying.";
  }

  if (
    verdict === AI_VERDICTS.TRAP_RISK &&
    d.rsi15Momentum === "loss"
  ) {
    reason += " RSI15 loss confirms trap risk.";
  }

  /* ================= MICRO TREND CONFIRMATION ================= */

  if (
    verdict === AI_VERDICTS.WAIT_FOR_PULLBACK &&
    d.emaShortCross === "bullish-cross" &&
    d.mainTrend === "bullish"
  ) {
    verdict = AI_VERDICTS.CONTROLLED_CONTINUATION;
    reason += " Micro Trend turned bullish.";
  }

  if (
    verdict === AI_VERDICTS.CONTROLLED_CONTINUATION &&
    d.emaShortCross === "bearish-cross"
  ) {
    verdict = AI_VERDICTS.WAIT_FOR_PULLBACK;
    reason += " Micro Trend weakening.";
  }

  return withTier(verdict, reason, d);
}

/* ================= TIER WRAPPER ================= */

function withTier(verdict, reason, d){
  const t = AI_VERDICT_TIERS[verdict] || {
    tier: 6,
    label: "TIER 6 ‚Äî UNKNOWN",
    verdictClass: "verdict-avoid"
  };

  let trendAlignment = "neutral";

  if (d.mainTrend === "bullish" && d.emaShortBias === "bullish")
    trendAlignment = "aligned";
  else if (d.mainTrend === "bearish" && d.emaShortBias === "bearish")
    trendAlignment = "aligned";
  else if (
    (d.mainTrend === "bullish" && d.emaShortBias === "bearish") ||
    (d.mainTrend === "bearish" && d.emaShortBias === "bullish")
  )
    trendAlignment = "conflict";
  else if (d.emaShortBias === "neutral")
    trendAlignment = "neutral";
  else
    trendAlignment = "pullback";

  const tradeSide = getTradeSide(d);
const executionZone = getExecutionZone(d, tradeSide);

  return {
    verdict,
    tier: t.tier,
    tierLabel: t.label,
    verdictClass: t.verdictClass,

    tradeSide: getTradeSide({
  ...d,
  aiVerdict: verdict
}),
    executionZone,

    mainTrend: d.mainTrend || "neutral",
    microTrend: d.emaShortBias || "neutral",
    microTrendCross: d.emaShortCross || "none",
    trendAlignment,

    reason
  };
}

/* ================= TRADE SIDE ================= */

function getTradeSide(d){
  const trend = d.mainTrend;
  const micro = d.emaShortBias;
  const volBias = d.volAI?.bias || "Neutral";
  const struct = d.structureType;
  const bias = d.bias || "";

  /* ================= TRAP OVERRIDE (HIGHEST PRIORITY) ================= */

  // üêª BEAR TRAP ‚Üí LONG
  if (bias.includes("Bear Trap")) {
    return "LONG";
  }

  // üêÇ BULL TRAP ‚Üí SHORT
  if (bias.includes("Bull Trap")) {
    return "SHORT";
  }

  /* ================= CLIMAX OVERRIDE ================= */

// ‚õî Buy climax ‚Üí do NOT chase longs
if (
  d.volAI &&
  d.volAI.meaning?.includes("Buy climax")
) {
  return "WAIT";
}

// ‚õî Sell climax ‚Üí do NOT chase shorts
if (
  d.volAI &&
  d.volAI.meaning?.includes("Sell exhaustion") === false &&
  d.volAI.meaning?.includes("Sell climax")
) {
  return "WAIT";
}

  /* ================= TREND ALIGNMENT ================= */

  if (trend === "bullish" && micro === "bullish") {
    return "LONG";
  }

  if (trend === "bearish" && micro === "bearish") {
    return "SHORT";
  }

  /* ================= VOLUME CAUTION (LOW PRIORITY) ================= */

  if (volBias === "Caution") {
    return "WAIT";
  }

  /* ================= STRUCTURE-BASED FALLBACK ================= */

  if (
    trend === "bullish" &&
    volBias === "Bullish" &&
    micro === "bullish" &&
    (
      struct === "support holding" ||
      struct === "resistance broken" ||
      struct === "resistance weak"
    )
  ) {
    return "LONG";
  }

  if (
    trend === "bearish" &&
    volBias === "Bearish" &&
    micro === "bearish" &&
    (
      struct === "support broken" ||
      struct === "resistance failed" ||
      struct === "support weak"
    )
  ) {
    return "SHORT";
  }

  return "WAIT";
}

  function getExecutionZone(d, tradeSide) {
  const volAI = d.volAI;
  if (!tradeSide || tradeSide === "WAIT") return "NO TRADE ZONE";

  const meaning = volAI?.meaning || "";
  const location = volAI?.location || "";

  /* ================= CLIMAX ================= */

  if (
    meaning.includes("Buy climax") ||
    meaning.includes("Sell climax")
  ) {
    return "WAIT";
  }

  /* ================= DISTRIBUTION / ACCUMULATION ================= */

  if (
    meaning.includes("Distribution") ||
    meaning.includes("Accumulation")
  ) {
    return "ENTRY ZONE";
  }

  /* ================= NEUTRAL / MID RANGE ================= */

  if (
    meaning === "Neutral" ||
    location === "MID"
  ) {
    return "PULLBACK ZONE";
  }

  return "NO TRADE ZONE";
  }
  

  function getStructureDirectionalBias(structureType, structureQuality){
  if (structureType === "resistance weak") return "bullish";
  if (structureType === "support weak") return "bearish";

  if (
    structureType === "resistance broken" ||
    structureType === "support holding"
  ) return "bullish";

  if (
    structureType === "support broken" ||
    structureType === "resistance failed"
  ) return "bearish";

  return "neutral";
  }
  

  function computeMarketDominance(tickers){
  let green = 0;
  let red = 0;

  tickers.forEach(t=>{
    const ch = +t.priceChangePercent;
    if(isNaN(ch)) return;

    if(ch > 0) green += ch;
    else if(ch < 0) red += Math.abs(ch);
  });

  const net = green - red;

  return {
    green: +green.toFixed(2),
    red: +red.toFixed(2),
    net: +net.toFixed(2),
    bias:
      net > 0 ? "Bull Dominant" :
      net < 0 ? "Bear Dominant" :
      "Neutral"
  };
  }

/* === IMPROVED 15m SWING DETECTION (CONFIRMED) === */
function findSwings(h, l, c, v){
  const supports = [];
  const resistances = [];

  // parameters (tunable but safe defaults)
  const LOOKBACK = 2;          // candles on each side
  const CONFIRM = 2;           // candles to confirm reaction
  const VOL_MULT = 1.2;        // volume must be above average

  const avgVol = v.slice(-40).reduce((a,b)=>a+b,0) / 40;

  for(let i = LOOKBACK; i < h.length - CONFIRM; i++){

    /* === SWING LOW (SUPPORT) === */
    let isSwingLow = true;
    for(let j = 1; j <= LOOKBACK; j++){
      if(l[i] >= l[i-j] || l[i] >= l[i+j]){
        isSwingLow = false;
        break;
      }
    }

    if(isSwingLow){
      // confirmation: price must move away upward
      let confirmed = true;
      for(let k = 1; k <= CONFIRM; k++){
        if(c[i+k] <= c[i]){
          confirmed = false;
          break;
        }
      }

      // volume filter (defense)
      if(confirmed && v[i] >= avgVol * VOL_MULT){
        supports.push(l[i]);
      }
    }

    /* === SWING HIGH (RESISTANCE) === */
    let isSwingHigh = true;
    for(let j = 1; j <= LOOKBACK; j++){
      if(h[i] <= h[i-j] || h[i] <= h[i+j]){
        isSwingHigh = false;
        break;
      }
    }

    if(isSwingHigh){
      // confirmation: price must move away downward
      let confirmed = true;
      for(let k = 1; k <= CONFIRM; k++){
        if(c[i+k] >= c[i]){
          confirmed = false;
          break;
        }
      }

      // volume filter (supply)
      if(confirmed && v[i] >= avgVol * VOL_MULT){
        resistances.push(h[i]);
      }
    }
  }

  return {
    supports: supports.slice(-2).reverse(),       // S1, S2
    resistances: resistances.slice(-2).reverse()  // R1, R2
  };
}

  function ema(values, period){
  const k = 2 / (period + 1);
  const result = Array(values.length).fill(null);

  let sum = 0;
  for(let i = 0; i < values.length; i++){
    const v = values[i];
    if(i < period){
      sum += v;
      if(i === period - 1){
        result[i] = sum / period; // SMA seed
      }
      continue;
    }
    result[i] = v * k + result[i - 1] * (1 - k);
  }
  return result;
  }

    /* ================= DAILY RSI CONTEXT ================= */
const DAILY_RSI_CACHE = {};
const DAILY_RSI_TTL = 6 * 60 * 60 * 1000; // 6 hours
const DAILY_RSI_INTERVAL = "1d";
const DAILY_RSI_LIMIT = 200;

  function mapKlines(klines){
  return klines.map(k => ({
    openTime: +k[0],
    open: +k[1],
    high: +k[2],
    low: +k[3],
    close: +k[4],
    baseVol: +k[5]
  }));
}

function safeNum(n){
  return isNaN(n) ? 0 : n;
}

  /* ================= RSI ================= */
function calculateRSI(closes, period=14){
  if(closes.length <= period) return [];
  let gains=0,losses=0,rsi=[];
  for(let i=1;i<=period;i++){
    const d=closes[i]-closes[i-1];
    d>0?gains+=d:losses-=d;
  }
  let avgG=gains/period, avgL=losses/period;
  rsi[period]=100-100/(1+(avgL===0?100:avgG/avgL));
  for(let i=period+1;i<closes.length;i++){
    const d=closes[i]-closes[i-1];
    avgG=(avgG*(period-1)+(d>0?d:0))/period;
    avgL=(avgL*(period-1)+(d<0?-d:0))/period;
    rsi[i]=100-100/(1+(avgL===0?100:avgG/avgL));
  }
  return rsi;
}

/* ================= RSI DIFF ================= */
function getRecentRSIDiff(rsi, lookback=14){
  const s=rsi.slice(-lookback);
  const hi=Math.max(...s);
  const lo=Math.min(...s);
  return {
    diff: +(hi - lo).toFixed(2),
    direction:
      s.at(-1)>s[0]?'pump':
      s.at(-1)<s[0]?'dump':'neutral'
  };
}

async function getDailyRSIContext(sym){
  const cached = DAILY_RSI_CACHE[sym];
  if(cached && Date.now() - cached.ts < DAILY_RSI_TTL){
    return cached.data;
  }

  try{
    const k = await fetchJSON(
      `${API}/fapi/v1/klines?symbol=${sym}&interval=${DAILY_RSI_INTERVAL}&limit=${DAILY_RSI_LIMIT}`
    );

    const closes = k.map(x=>+x[4]);
    const rsi = calculateRSI(closes);
    if(!rsi.length) return null;

    const rsiValue = rsi.at(-1); // ‚úÖ NOW SAFE

    const d = getRecentRSIDiff(rsi);

    let label = "Neutral";

    if (d.direction === "pump") {
      if (d.diff >= 30) label = "MAX ZONE PUMP";
      else if (d.diff >= 18 && d.diff <= 26) label = "BALANCE ZONE PUMP";
      else if (d.diff >= 1 && d.diff <= 10) label = "LOWEST ZONE PUMP";
    }
    else if (d.direction === "dump") {
      if (d.diff >= 30) label = "MAX ZONE DUMP";
      else if (d.diff >= 18 && d.diff <= 26) label = "BALANCE ZONE DUMP";
      else if (d.diff >= 1 && d.diff <= 10) label = "LOWEST ZONE DUMP";
    }

    const data = {
      label,
      diff: d.diff,
      dir: d.direction,
      value: +rsiValue.toFixed(2)
    };

    DAILY_RSI_CACHE[sym] = { data, ts: Date.now() };
    return data;

  }catch(e){
    console.error("Daily RSI failed:", sym, e);
    return null;
  }
}
  
  function isDailyRSIActive(){
  return filterDailyRSI.value !== "all";
  }

  function analyzeRSI50Behavior(rsiArr, lookback = 5) {
  if (!rsiArr || rsiArr.length < lookback) {
    return {
      consistentlyAbove50: false,
      consistentlyBelow50: false
    };
  }

  const recent = rsiArr.slice(-lookback);

  const above50 = recent.filter(v => v >= 50).length;
  const below50 = recent.filter(v => v < 50).length;

  return {
    consistentlyAbove50: above50 >= 3,
    consistentlyBelow50: below50 >= 3
  };
  }

  function getRSI15Momentum(rsi15Arr) {
  if (!rsi15Arr || rsi15Arr.length < 3) {
    return "neutral";
  }

  const r0 = rsi15Arr.at(-3);
  const r1 = rsi15Arr.at(-2);
  const r2 = rsi15Arr.at(-1);

  // strong reclaim
  if (r0 < 50 && r1 >= 50 && r2 > r1) return "reclaim";

  // strong loss
  if (r0 > 50 && r1 <= 50 && r2 < r1) return "loss";

  // acceleration
  if (r2 > r1 && r1 > r0 && r2 >= 55) return "accel";

  // decay
  if (r2 < r1 && r1 < r0 && r2 <= 45) return "decay";

  return "neutral";
  }

  async function batchMap(items, batchSize, asyncFn){
  const results = [];
  for(let i = 0; i < items.length; i += batchSize){
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(x => asyncFn(x).catch(() => null))
    );
    results.push(...batchResults);
  }
  return results;
  }

  function getMainTrendOnly(ema70, ema200, closes, opens, highs, lows){
  const len = ema70.length;
  if(len < 2) return "neutral";

  for(let i = len - 2; i >= 1; i--){
    if(ema70[i] <= ema200[i] && ema70[i+1] > ema200[i+1]){
      return "bullish";
    }
    if(ema70[i] >= ema200[i] && ema70[i+1] < ema200[i+1]){
      return "bearish";
    }
  }

  // fallback
  return ema70[len-1] >= ema200[len-1]
    ? "bullish"
    : "bearish";
  }

  function detect24hVolumeLocationAI(klines){
  if (!klines || klines.length < 96) return null;

  const last24h = klines.slice(-96).map(c => ({
    open: safeNum(c.open),
    high: safeNum(c.high),
    low: safeNum(c.low),
    close: safeNum(c.close),
    baseVol: safeNum(c.baseVol),
    openTime: c.openTime
  }));

  let dayHigh = -Infinity;
  let dayLow  = Infinity;

  for (const c of last24h) {
    if (c.high > dayHigh) dayHigh = c.high;
    if (c.low  < dayLow)  dayLow  = c.low;
  }

  let top = last24h[0];
  for (const c of last24h) {
    if (c.baseVol > top.baseVol) top = c;
  }

  const isRed   = top.close < top.open;
  const isGreen = top.close > top.open;

  const range = dayHigh - dayLow;
  const mid = dayLow + range * 0.5;

  let location = 'MID';
  if (top.high <= mid) location = 'LOW';
  else if (top.low >= mid) location = 'HIGH';

  let meaning = 'Neutral';
  let bias = 'Neutral';

  if (isRed && location === 'LOW') {
    meaning = 'Sell exhaustion ‚Üí bullish';
    bias = 'Bullish';
  } else if (isRed && location === 'HIGH') {
    meaning = 'Distribution ‚Üí bearish';
    bias = 'Bearish';
  } else if (isGreen && location === 'LOW') {
    meaning = 'Initiative buying ‚Üí bullish';
    bias = 'Bullish';
  } else if (isGreen && location === 'HIGH') {
    meaning = 'Buy climax ‚Üí caution';
    bias = 'Caution';
  }

  return {
    color: isRed ? 'RED' : 'GREEN',
    location,
    meaning,
    bias,
    volume: top.baseVol,
    time: top.openTime,
    high: top.high,
    low: top.low
  };
  }


/* ================= ANALYZE ================= */
async function analyze(sym,change){
  const k=await fetchJSON(`${API}/fapi/v1/klines?symbol=${sym}&interval=15m&limit=240`);
  await sleep(DELAY);

  const mappedK = mapKlines(k);

// üß† 24h Volume Location AI
const volAI = detect24hVolumeLocationAI(mappedK);

  const c=k.map(x=>+x[4]),h=k.map(x=>+x[2]),l=k.map(x=>+x[3]),v=k.map(x=>+x[5]);
  const price=c.at(-1);

    // üìä 15m RSI(14)
const rsi15Arr = calculateRSI(c, 14);
const rsi15 = rsi15Arr.length
  ? +rsi15Arr.at(-1).toFixed(2)
  : null;

  // üìà RSI slope (15m)
const rsi15Prev = rsi15Arr.length >= 2
  ? rsi15Arr.at(-2)
  : null;

const rsi15Rising =
  rsi15 !== null &&
  rsi15Prev !== null &&
  rsi15 > rsi15Prev;

  const rsi50State = analyzeRSI50Behavior(rsi15Arr);


  let domV = 0;
let domVBull = true;
let domVIndex = -1;


for(let i = k.length - 96; i < k.length - 1; i++){
  if(v[i] > domV){
    domV = v[i];
    domVBull = k[i][4] > k[i][1];
    domVIndex = i;
  }
}

  const ema14 = ema(c.slice(-100), 14);
const ema21 = ema(c.slice(-100), 21);
  const ema70 = ema(c.slice(-300), 70);
const ema200 = ema(c.slice(-300), 200);

const ema14Last = ema14.at(-1);
const ema21Last = ema21.at(-1);
const ema14Prev = ema14.at(-2);
const ema21Prev = ema21.at(-2);
  

  let emaShortBias = "neutral";
let emaShortCross = "none";

if (ema14Last > ema21Last) emaShortBias = "bullish";
else if (ema14Last < ema21Last) emaShortBias = "bearish";

if (ema14Prev <= ema21Prev && ema14Last > ema21Last)
  emaShortCross = "bullish-cross";

if (ema14Prev >= ema21Prev && ema14Last < ema21Last)
  emaShortCross = "bearish-cross";

const mainTrend = getMainTrendOnly(
  ema70,
  ema200,
  c,
  k.map(x=>+x[1]), // opens
  h,
  l
);


const lastVol = v.at(-1);
const lastBull = k.at(-1)[4] > k.at(-1)[1];

const volumeBreakout = lastVol > domV;
const volumeBreakoutType =
  volumeBreakout
    ? (lastBull ? "Bull Volume Breakout" : "Bear Volume Breakout")
    : "No Volume Breakout";

  // ‚è± breakout validity window (45 minutes = 3 x 15m candles)
const breakoutAge =
  volumeBreakout &&
  (Date.now() - k.at(-1)[6] < 45 * 60 * 1000);

  // direction conflict with main trend
const directionConflict =
  (mainTrend === "bullish" && lastBull === false) ||
  (mainTrend === "bearish" && lastBull === true);

// follow-through failure (current breakout candle closes against direction)
const followThroughFail =
  volumeBreakout &&
  (
    (lastBull && k.at(-1)[4] < k.at(-1)[1]) ||  // bull breakout but red close
    (!lastBull && k.at(-1)[4] > k.at(-1)[1])   // bear breakout but green close
  );

// climactic / distribution behavior
const climax =
  volAI &&
  (
    volAI.meaning.includes("climax") ||
    volAI.meaning.includes("Distribution")
  );

// FINAL fake volume breakout flag
const fakeVolumeBreak =
  volumeBreakout &&
  (directionConflict || climax) &&
  followThroughFail;

    // ‚úÖ Post-24h Volume Break RSI confirmation
const postVolBreakRSIConfirm =
  volumeBreakout &&          // 24h volume break happened
  rsi15 !== null &&
  rsi15 < 50 &&              // RSI reset
  rsi15Rising;            // RSI turning up 
  
  
  const bull = domVBull;

  const swings = findSwings(h,l,c,v);
const sw = {
  S: swings.supports || [],
  R: swings.resistances || []
};
  const sb=sw.S.some(x=>price<x);
  const rb=sw.R.some(x=>price>x);

  const rsi15Momentum = getRSI15Momentum(rsi15Arr);

  const bullishBreakAccepted =
  rb &&
  rsi15 !== null &&
  !rsi50State.consistentlyBelow50 &&
  rsi15Rising;

const bearishBreakAccepted =
  sb &&
  rsi15 !== null &&
  !rsi50State.consistentlyAbove50 &&
  !rsi15Rising;

  let bias="Neutral",prob=50,structure="none";
  if(bull){
   if (rb) {
  if (bullishBreakAccepted) {
    bias = "Bullish Continuation";
    prob = 90;
    structure = "resistance broken (accepted)";
  } else {
    bias = "Bull Trap Risk";
    prob = 55;
    structure = "resistance broken (unaccepted)";
  }
}
    else if (sw.S.length) {
  if (!rsi50State.consistentlyBelow50) {
    bias = "Bullish Defense";
    prob = 75;
    structure = "support holding (confirmed)";
  } else {
    bias = "Bull Trap Risk";
    prob = 45;
    structure = "support weak (RSI pressure)";
  }
}
  }else{
    if (sb) {
  if (bearishBreakAccepted) {
    bias = "Bearish Continuation";
    prob = 90;
    structure = "support broken (accepted)";
  } else {
    bias = "Bear Trap Risk";
    prob = 55;
    structure = "support broken (unaccepted)";
  }
}
    else if (sw.R.length) {
  if (!rsi50State.consistentlyAbove50) {
    bias = "Bearish Defense";
    prob = 75;
    structure = "resistance failed (confirmed)";
  } else {
    bias = "Bear Trap Risk";
    prob = 45;
    structure = "resistance weak (RSI pressure)";
  	}
  }
    else{bias="Bear Trap Risk";prob=40;}
  }

  const structureHolding =
  (mainTrend === "bullish" && structure !== "support broken") ||
  (mainTrend === "bearish" && structure !== "resistance broken");

  const structureType =
  structure.startsWith("support holding") ? "support holding" :
  structure.startsWith("support broken")  ? "support broken" :
  structure.startsWith("support weak")    ? "support weak" :
  structure.startsWith("resistance failed") ? "resistance failed" :
  structure.startsWith("resistance broken") ? "resistance broken" :
  structure.startsWith("resistance weak") ? "resistance weak" :
  "none";

const postVolBreakRSIConfirmSafe =
  postVolBreakRSIConfirm && structureHolding;

    const dailyRSI = await getDailyRSIContext(sym);

  const fundingRate = await getFundingRate(sym);

  return {sym,price,change,bull,prob,bias,structure,structureType,S:sw.S,R:sw.R,dailyRSI,rsi15,rsi15Momentum,volumeBreakout,
  breakoutAge,volumeBreakoutType,fakeVolumeBreak,postVolBreakRSIConfirm: postVolBreakRSIConfirmSafe,
  domV,
  lastVol,mainTrend,volAI,fundingRate,ema14: ema14Last,
  ema21: ema21Last,
  emaShortBias,
  emaShortCross};
}

/* ================= FILTERS ================= */
function applyFilters(){
  const b  = filterBias.value;
  const v  = filterVol.value;
  const p  = +filterProb.value;
  const r  = filterDailyRSI.value;
  const s  = filterStructure.value;
  const vb = filterVolBreak.value;
  const av = document.getElementById("filterAIVerdict")?.value || "all";
  const sq = document.getElementById("filterStructureQuality")?.value || "all";
  const ts = document.getElementById("filterTradeSide")?.value || "all";

  document.querySelectorAll(".card").forEach(c=>{
    let ok = true;

    if(b !== "all" && c.dataset.bias !== b) ok = false;
    if(v !== "all" && c.dataset.vol !== v) ok = false;
    if(p > 0 && +c.dataset.prob < p) ok = false;
    if(r !== "all" && c.dataset.dailyrsi !== r) ok = false;
    if (s !== "all" && c.dataset.structureType !== s) ok = false;
if (sq !== "all" && c.dataset.structureQuality !== sq) ok = false;
    if(vb !== "all" && c.dataset.volbreak !== vb) ok = false;

    // ü§ñ AI Verdict filter
    if(av !== "all" && c.dataset.aiverdict !== av) ok = false;
    if (ts !== "all" && c.dataset.tradeside !== ts) ok = false;

    c.style.display = ok ? "" : "none";
  });
}
  

         function resetFilters(){
  filterBias.value = "all";
  filterVol.value = "all";
  filterProb.value = "0";
  filterDailyRSI.value = "all";
  filterStructure.value = "all";
  filterVolBreak.value = "all";
  document.getElementById("filterAIVerdict").value = "all"; // üëà ADD
           document.getElementById("filterStructureQuality").value = "all";
           document.getElementById("filterTradeSide").value = "all";

  applyFilters();

  // üîî visual feedback
  const btn = document.getElementById("resetFiltersBtn");
  const oldText = btn.textContent;

  btn.textContent = "Reset ‚úì";
  btn.classList.add("reset-flash");

  setTimeout(()=>{
    btn.textContent = oldText;
    btn.classList.remove("reset-flash");
  }, 800);
}

  function applySort(){
  const field = document.getElementById("sortField").value;
  const order = document.getElementById("sortOrder").value;

  ["greenGrid","redGrid","favGrid","searchGrid"].forEach(id=>{
    const grid = document.getElementById(id);
    if(!grid) return;

    const cards = [...grid.children];

    cards.sort((a,b)=>{
      const av = +a.dataset[field];
      const bv = +b.dataset[field];
      return order === "asc" ? av - bv : bv - av;
    });

    cards.forEach(c=>grid.appendChild(c));
  });
    }
  
/* ================= RENDER ================= */
function renderCard(d, el, isFav=false){
  const scope = el.id || "global";
const id = `card-${scope}-${d.sym}`;
  let card = document.getElementById(id);

  // create only once
  if(!card){
    card = document.createElement("div");
    card.id = id;
    card.className = "card";
    el.appendChild(card);
  }

  const fundingInfo = getFundingInfo(d.fundingRate);

  const aiVerdict = getAIFinalVerdict(d);

  const tradeSideClass =
  aiVerdict.tradeSide === "LONG"
    ? "bull"
    : aiVerdict.tradeSide === "SHORT"
    ? "bear"
    : "neutral";

  
  card.dataset.bias = d.bias;
card.dataset.vol  = d.bull ? "bull" : "bear";
card.dataset.prob = d.prob;
card.dataset.change = d.change;
card.dataset.price = d.price;
card.dataset.structure = d.structure || "none";
card.dataset.dailyrsi = d.dailyRSI?.label || "all";
  card.dataset.volbreak = d.volumeBreakout ? "yes" : "no";
  card.dataset.trend = d.mainTrend || "neutral";
  card.dataset.aitier = aiVerdict.tier;
card.dataset.aiverdict = aiVerdict.verdict;
  card.dataset.structureType = d.structureType;
  card.dataset.tradeside = aiVerdict.tradeSide;

card.dataset.structureQuality =
  d.structure.includes("accepted") ? "accepted" :
  d.structure.includes("confirmed") ? "confirmed" :
  d.structure.includes("unaccepted") ? "unaccepted" :
  d.structure.includes("weak") ? "weak" :
  "none";
  

  // üîî SOUND ALERT ‚Äî only on 24h volume breakout
if (d.volumeBreakout) {
  const now = Date.now();

  // prevent repeat spam per symbol
  if (!volumeAlertCooldown[d.sym] || now - volumeAlertCooldown[d.sym] > ALERT_COOLDOWN) {
    volumeAlert.play().catch(()=>{});
    volumeAlertCooldown[d.sym] = now;
  }
}

  const structureBias = getStructureDirectionalBias(
  d.structureType,
  d.structureQuality
);
  
  
  card.innerHTML = `
    ${isFav
      ? `<div class="close" onclick="removeFav('${d.sym}')">‚úñ</div>`
      : `<div class="star" onclick="addFav('${d.sym}')">‚≠ê</div>`
    }
    <b>${d.sym}</b>
    <div class="muted">Price: ${d.price.toFixed(4)}</div>
    <div class="muted ${d.change>=0?"bull":"bear"}">
      24h Change: ${d.change.toFixed(2)}%
    </div>
    
    <div class="muted ${fundingInfo.cls}">
  üí∏ Funding Fee: ${fundingInfo.label}
</div>
    
    <div class="muted ${
  d.mainTrend === "bullish" ? "bull" :
  d.mainTrend === "bearish" ? "bear" : "neutral"
}">
  ${d.mainTrend === "bullish" ? "üìà" :
    d.mainTrend === "bearish" ? "üìâ" : "‚ûñ"}
  Main Trend: ${d.mainTrend.toUpperCase()}
</div>

 <div class="muted ${
  d.emaShortBias === "bullish" ? "bull" :
  d.emaShortBias === "bearish" ? "bear" : "neutral"
}">
  ${
    d.emaShortBias === "bullish" ? "üìà" :
    d.emaShortBias === "bearish" ? "üìâ" : "‚ûñ"
  }
  Micro Trend: ${d.emaShortBias.toUpperCase()}
  ${
    d.emaShortCross === "bullish-cross" ? " ‚¨Ü Cross" :
    d.emaShortCross === "bearish-cross" ? " ‚¨á Cross" : ""
  }
</div>
    
    ${d.dailyRSI ? `
  <div class="muted ${
    d.dailyRSI.value >= 50 ? "bull" :
    d.dailyRSI.value <= 50 ? "bear" : "neutral"
  }">
    üìÖ Daily RSI14: ${d.dailyRSI.value}
    <br>
    <span class="muted">
      ${d.dailyRSI.label} (Œî ${d.dailyRSI.diff})
    </span>
  </div>
` : ""}

${d.rsi15 !== null ? `
  <div class="muted ${
    d.rsi15 >= 60 ? "bull" :
    d.rsi15 <= 40 ? "bear" : "neutral"
  }">
    ‚è± 15m RSI14: ${d.rsi15}
  </div>
` : ""}

    <div class="muted ${d.bull?"bull":"bear"}">
      ${d.bull?"Bullish":"Bearish"} Volume Control
    </div>
    
      ${d.volumeBreakout ? `
  <div class="muted ${
    d.volumeBreakoutType.includes("Bull") ? "bull" : "bear"
  }">
    üî• ${d.volumeBreakoutType}
    <br>
    <span class="muted">
      15m: ${d.lastVol.toLocaleString()}
      &nbsp;‚Ä∫&nbsp;
      24h High: ${d.domV.toLocaleString()}
    </span>
  </div>
` : `
  <div class="muted neutral">
    üìä No 24h Volume Breakout
  </div>
`}

${d.postVolBreakRSIConfirm ? `
  <div class="muted verdict-strong">
    ‚úÖ Post-Volume RSI Confirmation
    <br>
    <span class="muted">
      RSI14 < 50 and turning up after 24h volume break
    </span>
  </div>
` : ""}

${d.volAI ? `
  <div class="muted ${
    d.volAI.bias === "Bullish" ? "bull" :
    d.volAI.bias === "Bearish" ? "bear" : "neutral"
  }">
    üß† 24h Volume AI
    <br>
    <span class="muted">
      ${d.volAI.color} candle ¬∑ ${d.volAI.location} range
    </span>
    <br>
    <span class="muted">
      ${d.volAI.meaning}
    </span>
  </div>
` : ""}

    <div class="muted ${structureBias === "bullish" ? "bull" : structureBias === "bearish" ? "bear" : "neutral"}">
  Structure: ${d.structure}
</div>

    <div class="prob ${
      d.bias.includes("Bull")?"bull":
      d.bias.includes("Bear")?"bear":"neutral"
    }">
      ${d.bias} ‚Äî ${d.prob}%
    </div>
    ${d.S[0]?`<div class="muted bear">S1: ${d.S[0].toFixed(4)}</div>`:""}
    ${d.S[1]?`<div class="muted bear">S2: ${d.S[1].toFixed(4)}</div>`:""}
    ${d.R[0]?`<div class="muted bull">R1: ${d.R[0].toFixed(4)}</div>`:""}
    ${d.R[1]?`<div class="muted bull">R2: ${d.R[1].toFixed(4)}</div>`:""}

    <hr style="opacity:.15">

<div class="muted ${aiVerdict.verdictClass}">
  üß† AI Verdict: <b>${aiVerdict.verdict}</b>
</div>

<div class="muted ${aiVerdict.verdictClass}">
  ${aiVerdict.tierLabel}
</div>

<div class="muted">
  ${aiVerdict.reason}
</div>

<div class="muted ${tradeSideClass}">
  üéØ Trade Side: <b>${aiVerdict.tradeSide}</b>
</div>
`;

  <div class="muted ${
  executionZone === "ENTRY ZONE" ? "bull" :
  executionZone === "PULLBACK ZONE" ? "neutral" :
  "bear"
}">
  üß≠ Execution Zone: <b>${executionZone}</b>
</div>

  applyFilters();
}

  async function runDailyRSIScan(targetLabel){
  greenGrid.innerHTML = "";
  redGrid.innerHTML = "";
  progressFill.style.width = "0%";

  dailyRSIMatchCount = 0;
  dailyRSIScanned = 0;

  const statusEl = document.getElementById("dailyRSIStatus");
  statusEl.textContent = `üìÖ Daily RSI Scan: ${targetLabel} ‚Äî starting‚Ä¶`;

  const tickers = await fetchJSON(`${API}/fapi/v1/ticker/24hr`);
  const usdt = tickers.filter(
    x => x.symbol.endsWith("USDT") && !BLACKSET.has(x.symbol)
  );

  const total = usdt.length;

  /* === PHASE 1: FAST DAILY RSI BATCH SCAN === */
  const BATCH_SIZE = 10; // üî• safe + fast

  const rsiResults = await batchMap(usdt, BATCH_SIZE, async (x)=>{
    const rsi = await getDailyRSIContext(x.symbol);
    dailyRSIScanned++;

    progressFill.style.width =
      Math.round((dailyRSIScanned / total) * 100) + "%";

    statusEl.textContent =
      `üìÖ Daily RSI Scan: ${targetLabel} | ` +
      `Scanned: ${dailyRSIScanned}/${total} | ` +
      `Matches: ${dailyRSIMatchCount}`;

    return rsi && rsi.label === targetLabel
      ? { symbol: x.symbol, change: +x.priceChangePercent }
      : null;
  });

  const matches = rsiResults.filter(Boolean);
  dailyRSIMatchCount = matches.length;

  /* === PHASE 2: SAFE 15m ANALYSIS (SEQUENTIAL) === */
  for(const m of matches){
    const d = await analyze(m.symbol, m.change);
    renderCard(
      d,
      m.change >= 0 ? greenGrid : redGrid
    );
    await sleep(120); // keep this slow & safe
  }

  timestamp.innerText = new Date().toLocaleString();
  statusEl.textContent =
    `üìÖ Daily RSI Scan COMPLETE ‚Äî ${targetLabel} | ` +
    `Total Matches: ${dailyRSIMatchCount}`;

  applySort();
  applyFilters();
}

 async function runVolumeBreakScan(){

  greenGrid.innerHTML = "";
  redGrid.innerHTML = "";
  progressFill.style.width = "3%";

  const tickers = await fetchJSON(`${API}/fapi/v1/ticker/24hr`);
  const usdt = tickers.filter(
    x => x.symbol.endsWith("USDT") && !BLACKSET.has(x.symbol)
  );

  const total = usdt.length;
  let scanned = 0;
  let matches = [];

  const BATCH_SIZE = 10;
  const BATCH_DELAY = 180;

  /* === PHASE 1: FAST DISCOVERY === */
  for (let i = 0; i < usdt.length; i += BATCH_SIZE) {
    const batch = usdt.slice(i, i + BATCH_SIZE);

    await Promise.all(
      batch.map(async x => {
        try {
          const k = await fetchJSON(
            `${API}/fapi/v1/klines?symbol=${x.symbol}&interval=15m&limit=97`
          );

          const v = k.map(c => +c[5]);

          let domV = 0;
          for (let j = 0; j < v.length - 2; j++) {
            if (v[j] > domV) domV = v[j];
          }

          const last = k.at(-1);
          const lastVol = +last[5];
          const lastTime = +last[6];

          const mem = VOLUME_BREAK_MEMORY[x.symbol];

          if (
            lastVol > domV &&
            (!mem || lastTime > mem.lastCandleTime)
          ) {
            matches.push({
              symbol: x.symbol,
              change: +x.priceChangePercent
            });

            VOLUME_BREAK_MEMORY[x.symbol] = {
              lastCandleTime: lastTime,
              domV
            };
          }
        } catch {}
      })
    );

    scanned += batch.length;
    progressFill.style.width =
      Math.round((scanned / total) * 100) + "%";

    setScanStatus(
      `üî• 24h Volume Break Scan | ${scanned}/${total} | Matches: ${matches.length}`
    );

    await sleep(BATCH_DELAY);
  }

  /* === PHASE 2: FULL ANALYSIS === */
  for (const m of matches) {
    const d = await analyze(m.symbol, m.change);
    renderCard(d, m.change >= 0 ? greenGrid : redGrid);
    await sleep(120);
  }

  timestamp.innerText = new Date().toLocaleString();

  setScanStatus(
    `üî• 24h Volume Break Scan COMPLETE ‚Äî Matches: ${matches.length}`
  );

  applySort();
  applyFilters();
  }

  
  async function run24hVolumeBreak(){

  // ‚õî cannot run yet ‚Üí queue
  if (scanLock) {
    pending24hVolumeScan = true;
    setScanStatus(
      "‚è≥ Normal scan running ‚Äî 24h Volume Break queued"
    );
    return;
  }

  // ‚úÖ now we can run
  pending24hVolumeScan = false;
  setScanStatus("üî• 24h Volume Break Scan ‚Äî running‚Ä¶");

  // ‚õî stop auto scans
  if(autoTimer) clearInterval(autoTimer);
  if(autoVolBreakTimer) clearInterval(autoVolBreakTimer);

  scanLock = true;
  isAutoScan = false;

  // üî• IMMEDIATE UI FEEDBACK
  scanVolBreakBtn.disabled = true;
  scanBtn.disabled = true;

  scanVolBreakBtn.textContent = "üî• Scanning 24h Volume‚Ä¶";
  scanVolBreakBtn.classList.add("analyze-running");

  progressFill.style.width = "0%";

  try {
    // üîç run scan
    await runVolumeBreakScan();
  } finally {
    // ‚úÖ restore UI (always runs)
    scanLock = false;
    scanBtn.disabled = false;
    scanVolBreakBtn.disabled = false;

    scanVolBreakBtn.textContent = "üî• Scan 24h Volume Break";
    scanVolBreakBtn.classList.remove("analyze-running");
    
    startAutoScan();
  }
}
  
/* ================= FAVORITES ================= */
async function addFav(sym){
  if(BLACKSET.has(sym)) return;
  favSet.add(sym);
  const t=await fetchJSON(`${API}/fapi/v1/ticker/24hr?symbol=${sym}`);
  const d=await analyze(sym,+t.priceChangePercent);
  renderCard(d,favGrid,true);
}
function removeFav(sym){
  favSet.delete(sym);
  favGrid.innerHTML="";
  favSet.forEach(addFav);
}

/* ================= SCAN ================= */
async function runScan() {
  // ‚õî prevent overlap
  if (scanLock) return;

  // üîí lock AFTER check
  scanLock = true;
  scanBtn.disabled = true;
  scanVolBreakBtn.disabled = true;

  setScanStatus(
    isAutoScan
      ? "üîÑ Auto Scan ‚Äî running‚Ä¶"
      : "üß≠ Manual Scan ‚Äî running‚Ä¶"
  );

  try {
    const dailyRSIFilter = filterDailyRSI.value;

    if (dailyRSIFilter !== "all") {
      await runDailyRSIScan(dailyRSIFilter);
      return;
    }

    // ‚ùó reset ONLY on manual scan
    if (!isAutoScan) {
      greenGrid.innerHTML = "";
      redGrid.innerHTML = "";
      progressFill.style.width = "0%";
    }

    const t = await fetchJSON(`${API}/fapi/v1/ticker/24hr`);
    const usdtAll = t.filter(
      x => x.symbol.endsWith("USDT") && !BLACKSET.has(x.symbol)
    );

    const dom = computeMarketDominance(usdtAll);

    marketGreen.textContent = `üü¢ Green: ${dom.green.toLocaleString()}%`;
    marketRed.textContent   = `üî¥ Red: ${dom.red.toLocaleString()}%`;
    marketNet.textContent   = `‚öñ Net: ${dom.net.toLocaleString()}% ‚Äî ${dom.bias}`;

    marketNet.className =
      dom.net > 0 ? "bull" :
      dom.net < 0 ? "bear" :
      "neutral";

    const usdt = usdtAll;
    const g = [...usdt].sort((a,b)=>b.priceChangePercent-a.priceChangePercent).slice(0,30);
    const r = [...usdt].sort((a,b)=>a.priceChangePercent-b.priceChangePercent).slice(0,30);
    const all = [...g, ...r];

    let done = 0;
    for (const x of all) {
      const d = await analyze(x.symbol, +x.priceChangePercent);
      renderCard(d, x.priceChangePercent >= 0 ? greenGrid : redGrid);
      done++;
      progressFill.style.width = Math.round(done / all.length * 100) + "%";
      await sleep(120);
    }

    // üîÑ auto-update search result
    if (activeSearchSymbol) {
      try {
        const t = await fetchJSON(
          `${API}/fapi/v1/ticker/24hr?symbol=${activeSearchSymbol}`
        );
        const d = await analyze(activeSearchSymbol, +t.priceChangePercent);
        renderCard(d, searchGrid);
      } catch {}
    }

  } finally {
    // üïí timing
    timestamp.innerText = new Date().toLocaleString();
    nextScanAt = Date.now() + AUTO_INTERVAL;
    startCountdown();

    scanLock = false;
    scanBtn.disabled = false;
    isAutoScan = false;
    scanVolBreakBtn.disabled = false;

    setScanStatus("üß≠ Scanner Status: Idle");
  }

  // üî• AUTO 24h VOLUME BREAK
  const now = Date.now();
  if (
  auto24hVolumeEnabled &&
  now - last24hVolumeBreakAt >= AUTO_VOLUME_BREAK_INTERVAL
) {
    last24hVolumeBreakAt = now;
    pending24hVolumeScan = true;

// ‚úÖ show message FIRST
statusLocked = false;
setScanStatus("‚è≥ 24h Volume Break scheduled (auto)");

// üîí lock AFTER message is visible
statusLocked = true;

    setTimeout(async () => {
      try {
        await run24hVolumeBreak();
      } finally {
        pending24hVolumeScan = false;
        statusLocked = false;
      }
    }, 800);
  }

  applySort();
  applyFilters();
  }
                          
  
  

/* ================= SEARCH ================= */
async function runSearch(){
  const status = document.getElementById("manualStatus");
  const btn = document.getElementById("analyzeBtn");
  const s = symbolSearch.value.toUpperCase();

  if(!s){
    status.textContent = "Manual status: No symbol entered";
    status.className = "muted status-error";
    return;
  }

  const sym = s.endsWith("USDT") ? s : s + "USDT";
  if(BLACKSET.has(sym)){
    status.textContent = `Manual status: ${sym} is blacklisted`;
    status.className = "muted status-error";
    return;
  }

  try{
  // üîí lock + animate button
  btn.disabled = true;
  btn.textContent = "Analyzing‚Ä¶";
  btn.classList.add("analyze-running");

  status.textContent = `Manual status: Analyzing ${sym}‚Ä¶`;
  status.className = "muted status-running";

  activeSearchSymbol = sym;
  searchGrid.innerHTML = "";

  const t = await fetchJSON(`${API}/fapi/v1/ticker/24hr?symbol=${sym}`);
  const d = await analyze(sym, +t.priceChangePercent);

  renderCard(d, searchGrid);

  status.textContent = `Manual status: ${sym} analysis completed`;
  status.className = "muted status-done";

}catch(err){
  console.error(err);
  status.textContent = `Manual status: Analysis failed`;
  status.className = "muted status-error";

}finally{
  // üîì unlock + reset button
  btn.disabled = false;
  btn.textContent = "Analyze";
  btn.classList.remove("analyze-running");
  }
}

["sortField","sortOrder"].forEach(id=>{
  document.getElementById(id).addEventListener("change", ()=>{
    applySort();
    applyFilters(); // keep filters applied
  });
});

[
  "filterBias",
  "filterVol",
  "filterProb",
  "filterStructure",
  "filterStructureQuality",
  "filterVolBreak",
  "filterAIVerdict",  // üëà ADD THIS
  "filterTradeSide"
].forEach(id=>{
  document.getElementById(id).addEventListener("change", applyFilters);
});

  document.getElementById("filterDailyRSI").addEventListener("change", async ()=>{
  if(filterDailyRSI.value === "all"){
    document.getElementById("dailyRSIStatus").textContent =
      "üìÖ Daily RSI Scan: ‚Äî";
    return;
  }

  // üî• start RSI scan immediately
  await runScan();
});

      setInterval(() => {
  const cutoff = Date.now() - 24 * 60 * 60 * 1000;
  for (const s in VOLUME_BREAK_MEMORY) {
    if (VOLUME_BREAK_MEMORY[s].lastCandleTime < cutoff) {
      delete VOLUME_BREAK_MEMORY[s];
    }
  }
}, 10 * 60 * 1000);

  const scrollTopBtn = document.getElementById("scrollTopBtn");

// show / hide button
window.addEventListener("scroll", () => {
  if (window.scrollY > 300) {
    scrollTopBtn.style.display = "block";
  } else {
    scrollTopBtn.style.display = "none";
  }
});

// smooth scroll to top
scrollTopBtn.addEventListener("click", () => {
  window.scrollTo({
    top: 0,
    behavior: "smooth"
  });
});

  scanVolBreakBtn.addEventListener("click", () => {
  if (scanLock) return;   // ‚õî block during scans
  run24hVolumeBreak();
});

  document.getElementById("toggle24hVolume").addEventListener("change", (e) => {
  auto24hVolumeEnabled = e.target.checked;

  if (!auto24hVolumeEnabled) {
    pending24hVolumeScan = false;
    statusLocked = false;
    setScanStatus("‚è∏ Auto 24h Volume Break: OFF");
  } else {
    setScanStatus("‚ñ∂ Auto 24h Volume Break: ON");
  }
});
</script>
</body>
</html>
